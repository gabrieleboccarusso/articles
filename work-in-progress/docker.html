<ol>
 <li>installing docker
   <ol>
    <li>ubuntu (linux)</li>
    <li>Windows</li>
    <li>MacOs</li>
   </ol>
 </li>
</ol>

<p>
 Docker is a way to deploy software by storing it in lightweight packages.
 <br>
 to check if docker is correctly installed run on the cli the command <code>docker -v</code>
</p>

<h2>What is <i>DevOps</i>?</h2>
<p>
 Docker is getting everyday more relevant into the world of DevOps and to fully understand it is important to make clear what DevOps is and what role plays into the modern software development scene.
 <br>
 <i>Dev</i> refers to software development and <i>Ops</i> to the related operations regarding the deployment, the release and the monitoring of the performance. DevOps bridges the gap between the development and the release of a software using a set of precise practices aimed to improve the workflow between quality assurance, continous development and continous integration of the software throught its whole lifecycle.
</p>
<p>
 IMAGE1
</p>

<h2>What is Docker?</h2>
<p>
 Docker is a set of products that use virtualization at the Operative System level to delived software in packages called containers. A docker container contains mainly two things:
 <ul>
  <li>Software source code</li>
  <li>Operative System files (binaries and libraries)</li>
 </ul>
 These two things, although being in the same container, are throughly separated so to not interfere with each other or other softwares. If such need would eventually arise Docker offers way and tools to do it.
 <br>
 IMAGE2
</p>
<p>
 The containers are the actual instances of an application. The source code to create a together (as to put all the different pieces together) is container in a file called <code>Dockerfile</code> and that is referenced as an <b>image</b>. An image is the source code of a container and a container is an instance of an image.
</p>

<h2>Docker's benefits</h2>
<p>
 Containerizing an application provides multiple benefits. First of them is to make an application agnostic from the computer where it is develop and from the server. With the container already having all that is needed to run the application there is the certainty that it will run the same on the development machine, on the server and on every different platform it is used thus being indipendent from the outside environment. 
</p>
<p>
 If a software needs a dependency as, for example, a specific version of a database, there will be no problem and difference between deployment and production as a container can also refer to a specific version of a dependency so to be sure that in any case the used libraries don't get mixed up between different machines.
</p>
<p>
 To wrap an application into a container scaling becomes easier as through creating multiple instances of the same image there is the possibility to create a load balancer that redirects the requests and if one container gets too much traffic or dies unexpectedlly due to an error the whole system will not go down and it will be easy to check the performance and metrics of that specific container.
 <br>
 IMAGE3
</p>

<h2>Getting Started</h2>
<p>
 By running in the command line <code>docker container run hello-world</code> docker will look for the <code>hello-world</code> image locally and if not found will download it and before running the image a message informing about the download of the image will be shown. The actual output of this line is:
 <pre><code>Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
 </code></pre>
 Images are to be consideres as immutable as they can't change after their creation.
 <br>
 To list all the locally available images run in the command line <code>docker image ls</code>
 <pre><code>REPOSITORY    TAG      IMAGE ID       CREATED         SIZE
hello-world   latest   feb5d9fea6a5   18 months ago   13.3kB
 </code></pre>
 Everytime an image is run it creates another container (so an instance). the file <code>Dockerfile</code> contains the commands used to build the image and its content resembles this:
 <pre><code># start image from a previously built image
FROM *image*:*tag*

# run cli command to install some dependencies
# or to perform an operation
RUN *cli command*

# run the cli command that will be execute on docker run
CMD *cli command executed on run*
 </code></pre>
 A dockerfile is written by a developer and docker <i>builds</i> the relative image and once it finishes it can also create containers (instances) of the build.
</p>
<p>
 A container contains only what is required to run the application. It is an isolated environment that can communicate with other containers through the TCP/UDP method.
 <br>
 To see all the container that are currently running run in the cli <code>docker container ls</code>
 <pre><code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</code></pre>
 and to see all the exited containers add the <code>-a</code> flag: <code>docker container ls -a</code>
 <pre><code>
CONTAINER ID   IMAGE         COMMAND   CREATED        STATUS                     PORTS     NAMES
914f05a2f6c3   hello-world   "/hello"  7 seconds ago   Exited (0) 4 seconds ago              clever_jones
 </code></pre>
</p>
<p>
 The Docker cli is divided, under the hood, in three parts:
 <ol>
  <li>The docker cli tool that accepts a request</li>
  <li>The Docker daemon that manages the images and the containers</li>
  <li>A REST API used to communicate with the daemon</li>
 </ol>
 The Docker cli offers more than 50 different commands but the foundamentals and simplest ones are going to be used for 90% of the time:
 <dl>
  <dt>
   <code>docker image ls</code>
  </dt>
  <dd>Lists all the images</dd>
  <dt>
   <code>docker image pull *image*</code>
  </dt>
  <dt>
   gets an image from the image registry and downloads it online if there isn't one available  locally
  </dt>
  <dt>
   <code>docker image rm *image name*</code>
  </dt>
  <dd>
   Deletes a specific image
  </dd>
  <dt>
   <code>docker container ls</code>
  </dt>
  <dd>
   Lists all the container currently running
  </dd>
  <dt>
   <code>docker container ls -a</code>
  </dt>
  <dd>
   Lists all containers, both running and exited
  </dd>
  <dt>
   <code>docker container rm *image id*</code>
  </dt>
  <dd>
   deletes a container by its id. It can also take the first few chars of the id and work anyway giving a warning only if there are more containers with an id that <i>start</i> the same. <br>Can accept multiple arguments
  </dd>
  <dt>
   <code>docker container stop *container name or id*</code>
  </dt>
  <dd>
   Stops a running container
  </dd>
 </dl> 
</p>